
#这道题是最长回文子串，这道题和上一道最长不重复子串应该是同一类题，上一道题里采用了递归便利的解法，思路简单但耗时长，时间复杂度高。题解中提到了一种新的思路即滑动窗口
#滑动窗口是通过首尾两个指针，检测当前窗口中是否满足条件，这样可以在o(n)复杂度内得出答案，此题我们尝试使用这种思路进行解题

#定义首尾两个指针，以及一个窗口，即数组
#然后每次都将指针中间的字符放到窗口中，然后判定是否是回文串，如果不是则头指针往后移动一次，再判定，若还不是则尾指针往前移动一次，循环往复，直至相遇

#思考后发现这个思路并不好做 实际上还是O(n2)复杂度

#重新思索后可以将字符串先逆转一次 得到两个字符串 分别是原始字符串 s1 以及逆转后的字符串 s2
#现在只要移动s2字符串中的字符，不断向左移动，然后每一位进行比较，相同的位最多多 那就是最长逆转字符。这样复杂度降为o(n)

#这个思路也不太对最终走了弯路

#可以考虑动态规划


class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 定义：dp[i][j]表示s[i]到s[j]为回文
        # 递推：dp[i][j]=dp[i+1][j-1]&(s[i]==s[j]) if j - i >= 2 else s[i]==s[j]
        ans = 1
        ansx=ansy=0
        n = len(s)
        dp = [[False] * (n) for _ in range(n)]
        for i in range(n-1,-1,-1):
            for j in range(i,n):
                dp[i][j]=dp[i+1][j-1]&(s[i]==s[j]) if j - i >= 2 else s[i]==s[j]
                if dp[i][j] and j - i + 1 > ans:
                    ans = j - i + 1
                    ansx,ansy=i,j
        return s[ansx:ansy+1]